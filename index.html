<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Boxy Playground</title>
<style>
  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    background: linear-gradient(135deg, #f1f3f4 0%, #e8eaed 100%);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  .header {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    padding: 20px;
    text-align: center;
  }

  .header h1 {
    margin: 0;
    font-size: 2rem;
    font-weight: 700;
    background: linear-gradient(135deg, #6b7280, #4b5563);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .header p {
    margin: 5px 0 0 0;
    color: #666;
    font-size: 0.9rem;
  }

  #toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    align-items: center;
    justify-content: center;
    padding: 20px;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    margin: 20px 20px 0 20px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .btn {
    padding: 12px 24px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    border: none;
    border-radius: 50px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
  }

  .btn:before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    transition: left 0.5s;
  }

  .btn:hover:before {
    left: 100%;
  }

  .btn-primary {
    background: linear-gradient(135deg, #f1f3f4 0%, #e8eaed 100%);
    color: #374151;
  }

  .btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(107, 114, 128, 0.3);
  }

  .btn-danger {
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
    color: white;
  }

  .btn-danger:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(255, 107, 107, 0.3);
  }

  .color-input-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    gap: 6px;
    background: rgba(255, 255, 255, 0.7);
    padding: 10px 14px;
    border-radius: 50px;
    border: 2px solid rgba(107, 114, 128, 0.2);
    transition: all 0.3s ease;
  }

  .color-input-wrapper:hover {
    border-color: rgba(107, 114, 128, 0.5);
    background: rgba(255, 255, 255, 0.9);
  }

  .color-input-wrapper label {
    font-weight: 600;
    color: #333;
    font-size: 14px;
  }

  #colorPicker {
    width: 28px;
    height: 28px;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: transform 0.2s ease;
  }

  #colorPicker:hover {
    transform: scale(1.1);
  }

  .canvas-container {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    flex: 1;
    margin: 20px 20px 20px 20px;
    padding: 0;
    position: relative;
  }

  #canvas {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.3);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  #canvas:hover {
    transform: translateY(-2px);
    box-shadow: 0 25px 80px rgba(0, 0, 0, 0.25);
  }


  .controls-group {
    display: flex;
    gap: 10px;
    align-items: center;
  }

  .opacity-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(255, 255, 255, 0.7);
    padding: 8px 16px;
    border-radius: 50px;
    border: 2px solid rgba(107, 114, 128, 0.2);
    transition: all 0.3s ease;
  }

  .opacity-controls:hover {
    border-color: rgba(107, 114, 128, 0.5);
    background: rgba(255, 255, 255, 0.9);
  }

  .opacity-controls label {
    font-weight: 600;
    color: #333;
    font-size: 14px;
    min-width: 50px;
  }

  .opacity-controls input[type="range"] {
    width: 80px;
    height: 4px;
    border-radius: 2px;
    background: #d1d5db;
    outline: none;
    cursor: pointer;
  }

  .opacity-controls input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: linear-gradient(135deg, #6b7280, #4b5563);
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }

  .opacity-controls input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: linear-gradient(135deg, #6b7280, #4b5563);
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }

  .opacity-controls span {
    color: #666;
    font-size: 14px;
    font-weight: 500;
    min-width: 35px;
    text-align: center;
  }

  @media (max-width: 768px) {
    .header h1 {
      font-size: 1.5rem;
    }

    #toolbar {
      flex-direction: column;
      gap: 10px;
    }

    .controls-group {
      flex-direction: column;
      width: 100%;
    }

    .btn {
      width: 100%;
      max-width: 200px;
    }

    #canvas {
      max-width: 90vw;
      max-height: 60vh;
    }
  }

  .fade-in {
    animation: fadeIn 0.6s ease-out;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .box-animation {
    animation: boxAppear 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }

  @keyframes boxAppear {
    from {
      transform: scale(0);
      opacity: 0;
    }
    to {
      transform: scale(1);
      opacity: 1;
    }
  }

  .zoom-controls {
    position: absolute;
    bottom: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 100;
  }

  .zoom-widget {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.3);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    min-width: 120px;
  }

  .zoom-buttons {
    display: flex;
    gap: 4px;
  }

  .zoom-btn {
    width: 36px;
    height: 36px;
    border: none;
    border-radius: 8px;
    background: linear-gradient(135deg, #f1f3f4 0%, #e8eaed 100%);
    color: #374151;
    font-size: 18px;
    font-weight: 700;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
  }

  .zoom-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
  }

  .zoom-btn:active {
    transform: translateY(0);
  }

  .zoom-level {
    font-size: 12px;
    font-weight: 600;
    color: #333;
    text-align: center;
  }

  .scale-info {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 10px 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.3);
    font-size: 12px;
    font-weight: 600;
    color: #333;
    text-align: center;
    min-width: 120px;
  }

  .workspace-info {
    background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
    color: white;
    border-radius: 50px;
    padding: 10px 20px;
    font-size: 14px;
    font-weight: 600;
    text-align: center;
    margin-top: 4px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    user-select: none;
    border: none;
  }

  .workspace-info:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
  }

  .workspace-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(255, 255, 255, 0.7);
    padding: 8px 16px;
    border-radius: 50px;
    border: 2px solid rgba(107, 114, 128, 0.2);
    transition: all 0.3s ease;
  }

  .workspace-controls:hover {
    border-color: rgba(107, 114, 128, 0.5);
    background: rgba(255, 255, 255, 0.9);
  }

  .workspace-controls label {
    font-weight: 600;
    color: #333;
    font-size: 14px;
  }

  .workspace-controls input {
    padding: 4px 8px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 14px;
    text-align: center;
  }

  .workspace-controls span {
    color: #666;
    font-size: 14px;
    font-weight: 500;
  }

  .btn-workspace {
    padding: 6px 12px;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    border: none;
    border-radius: 20px;
    background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
    color: white;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(67, 233, 123, 0.2);
  }

  .btn-workspace:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(67, 233, 123, 0.3);
  }

  .workspace-popup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(5px);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .workspace-popup.show {
    display: flex;
  }

  .workspace-modal {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(15px);
    border-radius: 20px;
    padding: 24px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.3);
    min-width: 320px;
    animation: modalSlideIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }

  @keyframes modalSlideIn {
    from {
      opacity: 0;
      transform: scale(0.8) translateY(20px);
    }
    to {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  .workspace-modal h3 {
    margin: 0 0 20px 0;
    font-size: 18px;
    font-weight: 700;
    color: #333;
    text-align: center;
    background: linear-gradient(135deg, #6b7280, #4b5563);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .workspace-form {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .workspace-input-group {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
  }

  .workspace-input-group label {
    font-weight: 600;
    color: #333;
    font-size: 14px;
  }

  .workspace-input-group input {
    padding: 8px 12px;
    border: 2px solid rgba(107, 114, 128, 0.2);
    border-radius: 8px;
    font-size: 14px;
    text-align: center;
    width: 80px;
    transition: border-color 0.2s ease;
  }

  .workspace-input-group input:focus {
    outline: none;
    border-color: rgba(107, 114, 128, 0.5);
  }

  .workspace-input-group span {
    color: #666;
    font-size: 14px;
    font-weight: 500;
  }

  .workspace-buttons {
    display: flex;
    gap: 12px;
    justify-content: center;
    margin-top: 8px;
  }

  .btn-modal {
    padding: 10px 20px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    border: none;
    border-radius: 50px;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
  }

  .btn-modal.primary {
    background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
    color: white;
  }

  .btn-modal.primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
  }

  .btn-modal.secondary {
    background: rgba(148, 163, 184, 0.2);
    color: #64748b;
  }

  .btn-modal.secondary:hover {
    background: rgba(148, 163, 184, 0.3);
    transform: translateY(-1px);
  }

  .layer-controls {
    display: flex;
    gap: 6px;
    margin-left: 8px;
  }

  .btn-layer {
    padding: 4px 12px;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    border: none;
    border-radius: 20px;
    background: linear-gradient(135deg, #f1f3f4 0%, #e8eaed 100%);
    color: #374151;
    transition: all 0.2s ease;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  }

  .btn-layer:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 10px rgba(107, 114, 128, 0.2);
  }

  .workspace-input-group {
    align-items: center;
  }
</style>
</head>
<body>

<div class="header fade-in">
  <h1>üü¶ Boxy</h1>
  <p>Modern Canvas Playground for Creative Box Design</p>
</div>

<div id="toolbar" class="fade-in">
  <div class="controls-group">
    <button id="addRect" class="btn btn-primary">Add</button>
    <button id="deleteRect" class="btn btn-danger">Delete</button>
  </div>

  <div class="color-input-wrapper">
    <label>Color:</label>
    <input type="color" id="colorPicker" value="#6b7280">
  </div>

  <button id="toggleDimensions" class="btn btn-primary">Show</button>

  <div class="opacity-controls">
    <label for="dimensionOpacity">Opacity:</label>
    <input type="range" id="dimensionOpacity" min="0.1" max="1.0" step="0.1" value="0.9">
    <span id="opacityValue">90%</span>
  </div>
</div>

<div class="canvas-container">
  <canvas id="canvas" width="1200" height="600" class="fade-in"></canvas>

  <div class="zoom-controls fade-in">
    <div class="zoom-widget">
      <div class="zoom-buttons">
        <button id="zoomOut" class="zoom-btn">‚àí</button>
        <button id="zoomIn" class="zoom-btn">+</button>
      </div>
      <div id="zoomLevel" class="zoom-level">100%</div>
    </div>

    <div class="scale-info">
      <div id="scaleRatio">1:1</div>
      <div class="workspace-info">900√ó450mm space</div>
    </div>
  </div>
</div>

<!-- Workspace Dimension Popup -->
<div id="workspacePopup" class="workspace-popup">
  <div class="workspace-modal">
    <h3>üìê Workspace Dimensions</h3>
    <div class="workspace-form">
      <div class="workspace-input-group">
        <label>Width:</label>
        <input type="number" id="workspaceWidth" value="900" min="10" max="5000">
        <span>mm</span>
      </div>
      <div class="workspace-input-group">
        <label>Height:</label>
        <input type="number" id="workspaceHeight" value="450" min="10" max="5000">
        <span>mm</span>
      </div>
      <div class="workspace-buttons">
        <button id="applyWorkspace" class="btn-modal primary">Apply Changes</button>
        <button id="cancelWorkspace" class="btn-modal secondary">Cancel</button>
      </div>
    </div>
  </div>
</div>

<!-- Box Dimension Popup -->
<div id="rectanglePopup" class="workspace-popup">
  <div class="workspace-modal">
    <h3>üìè Box Properties</h3>
    <div class="workspace-form">
      <div class="workspace-input-group">
        <label>Width:</label>
        <input type="number" id="rectangleWidth" value="0" min="5" max="5000" step="0.1">
        <span>mm</span>
      </div>
      <div class="workspace-input-group">
        <label>Height:</label>
        <input type="number" id="rectangleHeight" value="0" min="5" max="5000" step="0.1">
        <span>mm</span>
      </div>
      <div class="workspace-input-group">
        <label>Opacity:</label>
        <input type="range" id="rectangleOpacity" min="0.1" max="1.0" step="0.05" value="0.7">
        <span id="rectangleOpacityValue">100%</span>
      </div>
      <div class="workspace-input-group">
        <label>Layer:</label>
        <input type="number" id="rectangleZIndex" value="0" min="0" max="999">
        <div class="layer-controls">
          <button id="bringToFront" class="btn-layer">Top</button>
          <button id="sendToBack" class="btn-layer">Back</button>
        </div>
      </div>
      <div class="workspace-buttons">
        <button id="applyRectangle" class="btn-modal primary">Apply Changes</button>
        <button id="cancelRectangle" class="btn-modal secondary">Cancel</button>
      </div>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const addBtn = document.getElementById("addRect");
const deleteBtn = document.getElementById("deleteRect");
const colorPicker = document.getElementById("colorPicker");
const zoomInBtn = document.getElementById("zoomIn");
const zoomOutBtn = document.getElementById("zoomOut");
const zoomLevelDisplay = document.getElementById("zoomLevel");
const scaleRatioDisplay = document.getElementById("scaleRatio");
const workspaceWidthInput = document.getElementById("workspaceWidth");
const workspaceHeightInput = document.getElementById("workspaceHeight");
const applyWorkspaceBtn = document.getElementById("applyWorkspace");
const cancelWorkspaceBtn = document.getElementById("cancelWorkspace");
const workspacePopup = document.getElementById("workspacePopup");
const workspaceInfo = document.querySelector(".workspace-info");

const rectangleWidthInput = document.getElementById("rectangleWidth");
const rectangleHeightInput = document.getElementById("rectangleHeight");
const rectangleOpacitySlider = document.getElementById("rectangleOpacity");
const rectangleOpacityDisplay = document.getElementById("rectangleOpacityValue");
const rectangleZIndexInput = document.getElementById("rectangleZIndex");
const bringToFrontBtn = document.getElementById("bringToFront");
const sendToBackBtn = document.getElementById("sendToBack");
const applyRectangleBtn = document.getElementById("applyRectangle");
const cancelRectangleBtn = document.getElementById("cancelRectangle");
const rectanglePopup = document.getElementById("rectanglePopup");
const toggleDimensionsBtn = document.getElementById("toggleDimensions");
const dimensionOpacitySlider = document.getElementById("dimensionOpacity");
const opacityValueDisplay = document.getElementById("opacityValue");

let boxes = [];
let selected = null;
let dragOffset = { x: 0, y: 0 };
let resizing = false;
let dragging = false;
let zoom = 1.0;
let panX = 0;
let panY = 0;
let showAllDimensions = false; // Global toggle for showing dimensions
let dimensionOpacity = 0.9; // Configurable opacity for dimension labels (0.0 to 1.0)

const HANDLE_SIZE = 10;

// Real-world scale settings (all in millimeters)
let WORKSPACE_WIDTH_MM = 900; // 900 millimeters (90cm)
let WORKSPACE_HEIGHT_MM = 450; // 450 millimeters (45cm)
const BASE_SCALE = 1; // 1 pixel per millimeter at 100% zoom
const GRID_SIZE_MM = 10; // 10mm grid lines (1cm)

// Zoom levels
const ZOOM_LEVELS = [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 2.0, 3.0, 4.0];
let currentZoomIndex = 3; // Start at 100% (index 3)

// Modern color palette
const modernColors = [
  "#6b7280", "#9ca3af", "#d1d5db", "#e5e7eb",
  "#f3f4f6", "#374151", "#4b5563", "#1f2937",
  "#111827", "#f9fafb", "#ffffff", "#e6e6e6"
];

// --- Coordinate conversion helpers ---

function mmToPixels(millimeters) {
  return millimeters * BASE_SCALE;
}

function pixelsToMm(pixels) {
  return pixels / BASE_SCALE;
}

function screenToWorld(screenX, screenY) {
  return {
    x: (screenX - panX) / zoom,
    y: (screenY - panY) / zoom
  };
}

function worldToScreen(worldX, worldY) {
  return {
    x: worldX * zoom + panX,
    y: worldY * zoom + panY
  };
}

// --- Zoom and scale helpers ---

function updateZoomDisplay() {
  const zoomPercent = Math.round(zoom * 100);
  zoomLevelDisplay.textContent = `${zoomPercent}%`;

  // For millimeters, 1:1 means 1 pixel = 1mm, so the ratio is zoom dependent
  const scale = Math.round(1 / zoom);
  scaleRatioDisplay.textContent = scale === 1 ? `1:1` : `1:${scale}`;

  // Update button states
  zoomOutBtn.disabled = currentZoomIndex <= 0;
  zoomInBtn.disabled = currentZoomIndex >= ZOOM_LEVELS.length - 1;
}

function setZoom(newZoom) {
  // Center the zoom on the canvas center
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;

  // Calculate world position of center before zoom
  const worldCenter = screenToWorld(centerX, centerY);

  zoom = newZoom;

  // Recalculate pan to keep the center point stable
  const newScreen = worldToScreen(worldCenter.x, worldCenter.y);
  panX += centerX - newScreen.x;
  panY += centerY - newScreen.y;

  updateZoomDisplay();
  draw();
}

function getRandomModernColor() {
  return modernColors[Math.floor(Math.random() * modernColors.length)];
}

function drawGrid() {
  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Modern gradient background
  const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
  gradient.addColorStop(0, "#f8fafc");
  gradient.addColorStop(1, "#e2e8f0");
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Apply zoom and pan transform
  ctx.save();
  ctx.scale(zoom, zoom);
  ctx.translate(panX / zoom, panY / zoom);

  // Calculate grid spacing in world coordinates
  const gridSpacing = GRID_SIZE_MM * BASE_SCALE;

  // Draw workspace boundary
  const workspaceWidth = WORKSPACE_WIDTH_MM * BASE_SCALE;
  const workspaceHeight = WORKSPACE_HEIGHT_MM * BASE_SCALE;

  // Workspace background
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, 0, workspaceWidth, workspaceHeight);

  // Workspace border
  ctx.strokeStyle = "rgba(102, 126, 234, 0.5)";
  ctx.lineWidth = 2 / zoom;
  ctx.strokeRect(0, 0, workspaceWidth, workspaceHeight);

  // Grid lines (10mm spacing = 1cm)
  ctx.strokeStyle = "rgba(148, 163, 184, 0.3)";
  ctx.lineWidth = 0.5 / zoom;

  // Vertical lines
  for (let x = 0; x <= workspaceWidth; x += gridSpacing) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, workspaceHeight);
    ctx.stroke();
  }

  // Horizontal lines
  for (let y = 0; y <= workspaceHeight; y += gridSpacing) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(workspaceWidth, y);
    ctx.stroke();
  }

  ctx.restore();
  ctx.restore();
}

function drawRectangle(r, isSelected = false) {
  // Apply zoom and pan transform for boxes
  ctx.save();
  ctx.scale(zoom, zoom);
  ctx.translate(panX / zoom, panY / zoom);

  // Apply box opacity
  const boxOpacity = r.opacity || 1.0;
  ctx.globalAlpha = boxOpacity;

  if (isSelected) {
    // Glow effect for selected box
    ctx.shadowColor = `rgba(107, 114, 128, ${0.4 * boxOpacity})`;
    ctx.shadowBlur = 20 / zoom;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
  }

  // Main box
  ctx.fillStyle = r.color;
  ctx.fillRect(r.x, r.y, r.w, r.h);

  // Subtle inner shadow for depth
  const gradient = ctx.createLinearGradient(r.x, r.y, r.x, r.y + r.h);
  gradient.addColorStop(0, `rgba(255, 255, 255, ${0.3 * boxOpacity})`);
  gradient.addColorStop(1, `rgba(0, 0, 0, ${0.1 * boxOpacity})`);
  ctx.fillStyle = gradient;
  ctx.fillRect(r.x, r.y, r.w, r.h);

  if (isSelected) {
    // Modern selection border
    ctx.strokeStyle = "#9ca3af";
    ctx.lineWidth = 3 / zoom;
    ctx.setLineDash([8 / zoom, 4 / zoom]);
    ctx.lineDashOffset = Date.now() / 100 / zoom % 12; // Animated dashes
    ctx.strokeRect(r.x - 2 / zoom, r.y - 2 / zoom, r.w + 4 / zoom, r.h + 4 / zoom);

    // Modern resize handle
    const handleSize = HANDLE_SIZE / zoom;
    const handleX = r.x + r.w - handleSize;
    const handleY = r.y + r.h - handleSize;

    ctx.fillStyle = "#6b7280";
    ctx.shadowColor = "rgba(75, 85, 99, 0.5)";
    ctx.shadowBlur = 8 / zoom;
    ctx.fillRect(handleX, handleY, handleSize, handleSize);

    // Handle highlight
    ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
    ctx.fillRect(handleX, handleY, handleSize / 2, handleSize / 2);
  }

  ctx.restore();
}

function drawDimensions(r, isActive = false) {
  // Show dimensions based on global toggle OR if it's selected box during manipulation
  const shouldShow = showAllDimensions || (r === selected && isActive);
  if (!shouldShow) return;

  ctx.save();
  ctx.scale(zoom, zoom);
  ctx.translate(panX / zoom, panY / zoom);

  const wMm = pixelsToMm(r.w);
  const hMm = pixelsToMm(r.h);

  // Style for dimension text
  const fontSize = Math.max(10, 12 / zoom);
  ctx.font = `${fontSize}px "Segoe UI", sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  // Background style for dimension labels
  const padding = 4 / zoom;
  const borderRadius = 4 / zoom;

  // Width dimension (top of box)
  const widthText = `${wMm.toFixed(1)}mm`;
  const widthMetrics = ctx.measureText(widthText);
  const widthX = r.x + r.w / 2;
  const widthY = r.y - 15 / zoom;

  // Background for width
  ctx.fillStyle = `rgba(37, 99, 235, ${dimensionOpacity})`;
  ctx.fillRect(
    widthX - widthMetrics.width / 2 - padding,
    widthY - fontSize / 2 - padding,
    widthMetrics.width + padding * 2,
    fontSize + padding * 2
  );

  // Width text
  ctx.fillStyle = `rgba(255, 255, 255, ${dimensionOpacity})`;
  ctx.fillText(widthText, widthX, widthY);

  // Height dimension (right of box)
  const heightText = `${hMm.toFixed(1)}mm`;
  const heightMetrics = ctx.measureText(heightText);
  const heightX = r.x + r.w + 15 / zoom;
  const heightY = r.y + r.h / 2;

  // Background for height
  ctx.fillStyle = `rgba(37, 99, 235, ${dimensionOpacity})`;
  ctx.fillRect(
    heightX - heightMetrics.width / 2 - padding,
    heightY - fontSize / 2 - padding,
    heightMetrics.width + padding * 2,
    fontSize + padding * 2
  );

  // Height text
  ctx.fillStyle = `rgba(255, 255, 255, ${dimensionOpacity})`;
  ctx.fillText(heightText, heightX, heightY);

  ctx.restore();
}

function drawDistanceIndicators(r) {
  // Show distance indicators for selected box during selection, dragging, or resizing
  if (r !== selected) return;

  ctx.save();
  ctx.scale(zoom, zoom);
  ctx.translate(panX / zoom, panY / zoom);

  const workspaceWidth = WORKSPACE_WIDTH_MM * BASE_SCALE;
  const workspaceHeight = WORKSPACE_HEIGHT_MM * BASE_SCALE;

  // Helper function to find nearest box that intersects with a line in a specific direction
  function findNearestBox(direction) {
    let nearestBox = null;
    let minDistance = Infinity;

    for (const box of boxes) {
      if (box === r) continue; // Skip the selected box

      let distance = Infinity;
      let lineIntersects = false;

      switch (direction) {
        case 'left':
          // Cast horizontal line from center of left edge extending leftward
          // Line y-coordinate: r.y + r.h/2
          const leftLineY = r.y + r.h / 2;
          if (box.x + box.w <= r.x) {
            // Check if this specific horizontal line hits the box
            if (leftLineY >= box.y && leftLineY <= box.y + box.h) {
              distance = r.x - (box.x + box.w);
              lineIntersects = true;
            }
          }
          break;
        case 'right':
          // Cast horizontal line from center of right edge extending rightward
          // Line y-coordinate: r.y + r.h/2
          const rightLineY = r.y + r.h / 2;
          if (box.x >= r.x + r.w) {
            // Check if this specific horizontal line hits the box
            if (rightLineY >= box.y && rightLineY <= box.y + box.h) {
              distance = box.x - (r.x + r.w);
              lineIntersects = true;
            }
          }
          break;
        case 'top':
          // Cast vertical line from center of top edge extending upward
          // Line x-coordinate: r.x + r.w/2
          const topLineX = r.x + r.w / 2;
          if (box.y + box.h <= r.y) {
            // Check if this specific vertical line hits the box
            if (topLineX >= box.x && topLineX <= box.x + box.w) {
              distance = r.y - (box.y + box.h);
              lineIntersects = true;
            }
          }
          break;
        case 'bottom':
          // Cast vertical line from center of bottom edge extending downward
          // Line x-coordinate: r.x + r.w/2
          const bottomLineX = r.x + r.w / 2;
          if (box.y >= r.y + r.h) {
            // Check if this specific vertical line hits the box
            if (bottomLineX >= box.x && bottomLineX <= box.x + box.w) {
              distance = box.y - (r.y + r.h);
              lineIntersects = true;
            }
          }
          break;
      }

      if (lineIntersects && distance < minDistance) {
        minDistance = distance;
        nearestBox = box;
      }
    }

    return nearestBox ? { box: nearestBox, distance: minDistance } : null;
  }

  // Style for distance indicators
  const fontSize = Math.max(9, 10 / zoom);
  ctx.font = `${fontSize}px "Segoe UI", sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  const padding = 3 / zoom;
  const lineWidth = 1 / zoom;

  // Colors for different distance indicators
  const boxDistanceColor = "rgba(16, 185, 129, 0.9)"; // Green for box-to-box distances
  const edgeDistanceColor = "rgba(99, 102, 241, 0.9)"; // Blue for distances to workspace edge
  const boxLineColor = "rgba(16, 185, 129, 0.6)";
  const edgeLineColor = "rgba(99, 102, 241, 0.6)";
  const textColor = "white";

  // Helper function to draw distance indicator
  function drawDistance(x1, y1, x2, y2, text, labelX, labelY, isBoxToBox = false) {
    const currentLineColor = isBoxToBox ? boxLineColor : edgeLineColor;
    const currentDistanceColor = isBoxToBox ? boxDistanceColor : edgeDistanceColor;

    // Draw dashed line with slight glow
    ctx.shadowColor = currentLineColor;
    ctx.shadowBlur = 2 / zoom;
    ctx.strokeStyle = currentLineColor;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash([4 / zoom, 3 / zoom]);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.setLineDash([]); // Reset dash
    ctx.shadowBlur = 0; // Reset shadow

    // Draw end arrows for better visual guidance
    const arrowSize = 3 / zoom;
    const isHorizontal = Math.abs(x2 - x1) > Math.abs(y2 - y1);

    ctx.strokeStyle = currentLineColor;
    if (isHorizontal) {
      // Horizontal line - draw vertical arrows at ends
      // Left arrow
      ctx.beginPath();
      ctx.moveTo(x1, y1 - arrowSize);
      ctx.lineTo(x1, y1 + arrowSize);
      ctx.stroke();
      // Right arrow
      ctx.beginPath();
      ctx.moveTo(x2, y2 - arrowSize);
      ctx.lineTo(x2, y2 + arrowSize);
      ctx.stroke();
    } else {
      // Vertical line - draw horizontal arrows at ends
      // Top arrow
      ctx.beginPath();
      ctx.moveTo(x1 - arrowSize, y1);
      ctx.lineTo(x1 + arrowSize, y1);
      ctx.stroke();
      // Bottom arrow
      ctx.beginPath();
      ctx.moveTo(x2 - arrowSize, y2);
      ctx.lineTo(x2 + arrowSize, y2);
      ctx.stroke();
    }

    // Draw rounded text background with subtle shadow
    const textMetrics = ctx.measureText(text);
    const rectWidth = textMetrics.width + padding * 2;
    const rectHeight = fontSize + padding * 2;
    const rectX = labelX - rectWidth / 2;
    const rectY = labelY - rectHeight / 2;

    // Background shadow
    ctx.shadowColor = "rgba(0, 0, 0, 0.15)";
    ctx.shadowBlur = 4 / zoom;
    ctx.shadowOffsetX = 1 / zoom;
    ctx.shadowOffsetY = 1 / zoom;

    // Draw rounded rectangle background (with fallback for older browsers)
    ctx.fillStyle = currentDistanceColor;
    ctx.beginPath();
    if (ctx.roundRect) {
      ctx.roundRect(rectX, rectY, rectWidth, rectHeight, 3 / zoom);
    } else {
      // Fallback to regular rectangle for older browsers
      ctx.rect(rectX, rectY, rectWidth, rectHeight);
    }
    ctx.fill();

    // Reset shadow
    ctx.shadowColor = "transparent";
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // Draw text with slight emboss effect
    ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
    ctx.fillText(text, labelX + 0.5 / zoom, labelY + 0.5 / zoom);
    ctx.fillStyle = textColor;
    ctx.fillText(text, labelX, labelY);

    // Add a small indicator icon to show if this is box-to-box or box-to-edge distance
    const iconSize = 4 / zoom;
    const iconX = labelX + textMetrics.width / 2 + padding;
    const iconY = labelY;

    if (isBoxToBox) {
      // Small filled square for box-to-box distance
      ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
      ctx.fillRect(iconX - iconSize / 2, iconY - iconSize / 2, iconSize, iconSize);
    } else {
      // Small filled circle for box-to-edge distance
      ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
      ctx.beginPath();
      ctx.arc(iconX, iconY, iconSize / 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Left distance indicator
  const leftNearest = findNearestBox('left');
  if (leftNearest) {
    // Distance to nearest box on the left
    const distanceMm = pixelsToMm(leftNearest.distance);
    const leftText = `${distanceMm.toFixed(1)}mm`;
    const midY = r.y + r.h / 2;
    const nearestBox = leftNearest.box;
    drawDistance(nearestBox.x + nearestBox.w, midY, r.x, midY, leftText, nearestBox.x + nearestBox.w + leftNearest.distance / 2, midY, true);
  } else if (r.x > 0) {
    // Distance to workspace edge
    const distanceMm = pixelsToMm(r.x);
    const leftText = `${distanceMm.toFixed(1)}mm`;
    const midY = r.y + r.h / 2;
    drawDistance(0, midY, r.x, midY, leftText, r.x / 2, midY, false);
  }

  // Right distance indicator
  const rightNearest = findNearestBox('right');
  if (rightNearest) {
    // Distance to nearest box on the right
    const distanceMm = pixelsToMm(rightNearest.distance);
    const rightText = `${distanceMm.toFixed(1)}mm`;
    const midY = r.y + r.h / 2;
    const nearestBox = rightNearest.box;
    const startX = r.x + r.w;
    drawDistance(startX, midY, nearestBox.x, midY, rightText, startX + rightNearest.distance / 2, midY, true);
  } else if (r.x + r.w < workspaceWidth) {
    // Distance to workspace edge
    const distanceMm = pixelsToMm(workspaceWidth - (r.x + r.w));
    const rightText = `${distanceMm.toFixed(1)}mm`;
    const midY = r.y + r.h / 2;
    const startX = r.x + r.w;
    drawDistance(startX, midY, workspaceWidth, midY, rightText, startX + (workspaceWidth - startX) / 2, midY, false);
  }

  // Top distance indicator
  const topNearest = findNearestBox('top');
  if (topNearest) {
    // Distance to nearest box above
    const distanceMm = pixelsToMm(topNearest.distance);
    const topText = `${distanceMm.toFixed(1)}mm`;
    const midX = r.x + r.w / 2;
    const nearestBox = topNearest.box;
    drawDistance(midX, nearestBox.y + nearestBox.h, midX, r.y, topText, midX, nearestBox.y + nearestBox.h + topNearest.distance / 2, true);
  } else if (r.y > 0) {
    // Distance to workspace edge
    const distanceMm = pixelsToMm(r.y);
    const topText = `${distanceMm.toFixed(1)}mm`;
    const midX = r.x + r.w / 2;
    drawDistance(midX, 0, midX, r.y, topText, midX, r.y / 2, false);
  }

  // Bottom distance indicator
  const bottomNearest = findNearestBox('bottom');
  if (bottomNearest) {
    // Distance to nearest box below
    const distanceMm = pixelsToMm(bottomNearest.distance);
    const bottomText = `${distanceMm.toFixed(1)}mm`;
    const midX = r.x + r.w / 2;
    const nearestBox = bottomNearest.box;
    const startY = r.y + r.h;
    drawDistance(midX, startY, midX, nearestBox.y, bottomText, midX, startY + bottomNearest.distance / 2, true);
  } else if (r.y + r.h < workspaceHeight) {
    // Distance to workspace edge
    const distanceMm = pixelsToMm(workspaceHeight - (r.y + r.h));
    const bottomText = `${distanceMm.toFixed(1)}mm`;
    const midX = r.x + r.w / 2;
    const startY = r.y + r.h;
    drawDistance(midX, startY, midX, workspaceHeight, bottomText, midX, startY + (workspaceHeight - startY) / 2, false);
  }

  ctx.restore();
}

function draw() {
  drawGrid();

  // Sort boxes by zIndex for proper layering (lower zIndex drawn first)
  const sortedBoxes = [...boxes].sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));

  for (const r of sortedBoxes) {
    drawRectangle(r, r === selected);
    // Show dimensions based on global toggle or active manipulation
    const isActiveManipulation = (r === selected && (resizing || dragging));
    drawDimensions(r, isActiveManipulation);

    // Show distance indicators when dragging or resizing selected box
    drawDistanceIndicators(r);
  }
}

function hitTest(screenX, screenY) {
  // Convert screen coordinates to world coordinates
  const world = screenToWorld(screenX, screenY);

  // Sort boxes by zIndex in descending order (highest zIndex first) for hit testing
  const sortedBoxes = [...boxes].sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));

  for (const r of sortedBoxes) {
    if (world.x >= r.x && world.x <= r.x + r.w && world.y >= r.y && world.y <= r.y + r.h) {
      return r;
    }
  }
  return null;
}

function selectRectangle(r) {
  selected = r;
  draw();
  if (selected && /^#[0-9a-f]{6}$/i.test(selected.color)) {
    colorPicker.value = selected.color;
  }
}

function animateRectangleCreation(rect) {
  const startTime = Date.now();
  const duration = 300;
  const initialScale = 0;

  function animate() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const easeOutBack = 1 + 2.7 * Math.pow(progress - 1, 3) + 1.7 * Math.pow(progress - 1, 2);

    const scale = initialScale + (1 - initialScale) * easeOutBack;

    // Store original dimensions
    const originalW = rect.originalW || rect.w;
    const originalH = rect.originalH || rect.h;

    if (!rect.originalW) {
      rect.originalW = rect.w;
      rect.originalH = rect.h;
    }

    // Apply scaling from center
    const centerX = rect.x + originalW / 2;
    const centerY = rect.y + originalH / 2;

    rect.w = originalW * scale;
    rect.h = originalH * scale;
    rect.x = centerX - rect.w / 2;
    rect.y = centerY - rect.h / 2;

    draw();

    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      // Cleanup
      delete rect.originalW;
      delete rect.originalH;
    }
  }

  animate();
}

// --- Mouse handlers ---

function onMouseDown(e) {
  const rect = canvas.getBoundingClientRect();
  const screenX = e.clientX - rect.left;
  const screenY = e.clientY - rect.top;
  const r = hitTest(screenX, screenY);

  if (r) {
    selected = r;
    const world = screenToWorld(screenX, screenY);
    const handleSize = HANDLE_SIZE / zoom;

    if (world.x >= r.x + r.w - handleSize && world.y >= r.y + r.h - handleSize) {
      resizing = true;
      dragging = false;
      canvas.style.cursor = "nw-resize";
    } else {
      resizing = false;
      dragging = true;
      canvas.style.cursor = "move";
      dragOffset.x = world.x - r.x;
      dragOffset.y = world.y - r.y;
    }
  } else {
    selected = null;
    resizing = false;
    dragging = false;
    canvas.style.cursor = "default";
  }
  selectRectangle(selected);
}

function onMouseMove(e) {
  const rect = canvas.getBoundingClientRect();
  const screenX = e.clientX - rect.left;
  const screenY = e.clientY - rect.top;

  // Update cursor based on hover state
  if (!selected || e.buttons !== 1) {
    const hoverRect = hitTest(screenX, screenY);
    if (hoverRect) {
      const world = screenToWorld(screenX, screenY);
      const handleSize = HANDLE_SIZE / zoom;
      if (world.x >= hoverRect.x + hoverRect.w - handleSize && world.y >= hoverRect.y + hoverRect.h - handleSize) {
        canvas.style.cursor = "nw-resize";
      } else {
        canvas.style.cursor = "move";
      }
    } else {
      canvas.style.cursor = "default";
    }
  }

  if (!selected) return;

  const world = screenToWorld(screenX, screenY);

  if (resizing && e.buttons === 1) {
    const minSize = 5; // 5mm minimum size
    selected.w = Math.max(minSize * BASE_SCALE, world.x - selected.x);
    selected.h = Math.max(minSize * BASE_SCALE, world.y - selected.y);
    draw();
    updateInfo();
  } else if (!resizing && e.buttons === 1) {
    const workspaceWidth = WORKSPACE_WIDTH_MM * BASE_SCALE;
    const workspaceHeight = WORKSPACE_HEIGHT_MM * BASE_SCALE;

    selected.x = Math.max(0, Math.min(workspaceWidth - selected.w, world.x - dragOffset.x));
    selected.y = Math.max(0, Math.min(workspaceHeight - selected.h, world.y - dragOffset.y));
    draw();
  }
}

function onMouseUp() {
  resizing = false;
  dragging = false;
  canvas.style.cursor = "default";
}

function onDoubleClick(e) {
  const rect = canvas.getBoundingClientRect();
  const screenX = e.clientX - rect.left;
  const screenY = e.clientY - rect.top;
  const r = hitTest(screenX, screenY);

  if (r) {
    // Select the box and show its dimension popup
    selected = r;
    selectRectangle(r);
    showRectanglePopup();
  }
}

// --- Toolbar actions ---

addBtn.onclick = () => {
  const color = colorPicker.value || getRandomModernColor();

  // Create boxes in world coordinates (within the workspace)
  const workspaceWidth = WORKSPACE_WIDTH_MM * BASE_SCALE;
  const workspaceHeight = WORKSPACE_HEIGHT_MM * BASE_SCALE;

  // Get max z-index of existing boxes to place new box at same level
  const maxZ = boxes.length > 0 ? Math.max(...boxes.map(b => b.zIndex || 0)) : 0;

  const r = {
    x: Math.random() * (workspaceWidth - 50) + 10,
    y: Math.random() * (workspaceHeight - 30) + 10,
    w: 20 + Math.random() * 80,  // 20mm to 100mm wide
    h: 15 + Math.random() * 50,  // 15mm to 65mm tall
    color,
    opacity: 0.7,  // Individual box opacity (70% by default)
    zIndex: maxZ  // Layer ordering (equal to max existing z-index)
  };
  boxes.push(r);
  selectRectangle(r);
  animateRectangleCreation(r);
};

deleteBtn.onclick = () => {
  if (!selected) return;

  // Smooth fade out animation
  const rectToDelete = selected;
  const startTime = Date.now();
  const duration = 200;

  function fadeOut() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const opacity = 1 - progress;

    ctx.save();
    ctx.globalAlpha = opacity;
    draw();
    ctx.restore();

    if (progress < 1) {
      requestAnimationFrame(fadeOut);
    } else {
      boxes = boxes.filter(r => r !== rectToDelete);
      selected = null;
      draw();
      updateInfo();
    }
  }

  fadeOut();
};

colorPicker.addEventListener("input", () => {
  if (selected) {
    selected.color = colorPicker.value;
    draw();
  }
});

// --- Popup controls ---

function showWorkspacePopup() {
  // Update inputs with current values
  workspaceWidthInput.value = WORKSPACE_WIDTH_MM;
  workspaceHeightInput.value = WORKSPACE_HEIGHT_MM;

  workspacePopup.classList.add('show');
}

function hideWorkspacePopup() {
  workspacePopup.classList.remove('show');
}

function showRectanglePopup() {
  if (!selected) return;

  // Update inputs with current box dimensions
  const wMm = pixelsToMm(selected.w);
  const hMm = pixelsToMm(selected.h);
  const boxOpacity = selected.opacity || 1.0;
  const boxZIndex = selected.zIndex || 0;

  rectangleWidthInput.value = wMm.toFixed(1);
  rectangleHeightInput.value = hMm.toFixed(1);
  rectangleOpacitySlider.value = boxOpacity.toFixed(2);
  rectangleOpacityDisplay.textContent = `${Math.round(boxOpacity * 100)}%`;
  rectangleZIndexInput.value = boxZIndex;

  rectanglePopup.classList.add('show');
}

function hideRectanglePopup() {
  rectanglePopup.classList.remove('show');
}

workspaceInfo.onclick = () => {
  showWorkspacePopup();
};

// Global dimensions toggle button
toggleDimensionsBtn.onclick = () => {
  showAllDimensions = !showAllDimensions;
  toggleDimensionsBtn.textContent = showAllDimensions ? "Hide" : "Show";
  draw();
};

// Dimension opacity control
dimensionOpacitySlider.addEventListener("input", () => {
  dimensionOpacity = parseFloat(dimensionOpacitySlider.value);
  const percentage = Math.round(dimensionOpacity * 100);
  opacityValueDisplay.textContent = `${percentage}%`;
  draw();
});

// Rectangle opacity control in popup
rectangleOpacitySlider.addEventListener("input", () => {
  const opacity = parseFloat(rectangleOpacitySlider.value);
  const percentage = Math.round(opacity * 100);
  rectangleOpacityDisplay.textContent = `${percentage}%`;

  // Update selected box opacity in real-time
  if (selected) {
    selected.opacity = opacity;
    draw();
  }
});

// Layer ordering controls
bringToFrontBtn.onclick = () => {
  if (!selected) return;

  // Find highest zIndex and set selected box to be above it
  const maxZ = Math.max(...boxes.map(b => b.zIndex || 0));
  selected.zIndex = maxZ + 1;
  rectangleZIndexInput.value = selected.zIndex;
  draw();
};

sendToBackBtn.onclick = () => {
  if (!selected) return;

  // Find lowest zIndex and set selected box to be below it
  const minZ = Math.min(...boxes.map(b => b.zIndex || 0));
  selected.zIndex = Math.max(0, minZ - 1);
  rectangleZIndexInput.value = selected.zIndex;
  draw();
};

// Z-index input change
rectangleZIndexInput.addEventListener("input", () => {
  if (!selected) return;

  const zIndex = parseInt(rectangleZIndexInput.value) || 0;
  selected.zIndex = Math.max(0, zIndex);
  draw();
});

applyWorkspaceBtn.onclick = () => {
  const newWidth = parseInt(workspaceWidthInput.value);
  const newHeight = parseInt(workspaceHeightInput.value);

  if (newWidth >= 10 && newWidth <= 5000 && newHeight >= 10 && newHeight <= 5000) {
    WORKSPACE_WIDTH_MM = newWidth;
    WORKSPACE_HEIGHT_MM = newHeight;

    // Update workspace info display
    workspaceInfo.textContent = `${WORKSPACE_WIDTH_MM}√ó${WORKSPACE_HEIGHT_MM}mm space`;

    // Re-center the workspace
    initializeApp();

    // Hide popup
    hideWorkspacePopup();
  }
};

cancelWorkspaceBtn.onclick = () => {
  hideWorkspacePopup();
};

applyRectangleBtn.onclick = () => {
  if (!selected) return;

  const newWidth = parseFloat(rectangleWidthInput.value);
  const newHeight = parseFloat(rectangleHeightInput.value);
  const newOpacity = parseFloat(rectangleOpacitySlider.value);
  const newZIndex = parseInt(rectangleZIndexInput.value) || 0;

  if (newWidth >= 5 && newWidth <= 5000 && newHeight >= 5 && newHeight <= 5000) {
    // Convert millimeters back to pixels
    selected.w = newWidth * BASE_SCALE;
    selected.h = newHeight * BASE_SCALE;

    // Apply opacity and z-index
    selected.opacity = newOpacity;
    selected.zIndex = Math.max(0, newZIndex);

    // Keep box within workspace bounds
    const workspaceWidth = WORKSPACE_WIDTH_MM * BASE_SCALE;
    const workspaceHeight = WORKSPACE_HEIGHT_MM * BASE_SCALE;

    if (selected.x + selected.w > workspaceWidth) {
      selected.x = workspaceWidth - selected.w;
    }
    if (selected.y + selected.h > workspaceHeight) {
      selected.y = workspaceHeight - selected.h;
    }

    draw();
    updateInfo();
    hideRectanglePopup();
  }
};

cancelRectangleBtn.onclick = () => {
  hideRectanglePopup();
};

// Close popups when clicking outside modal
workspacePopup.onclick = (e) => {
  if (e.target === workspacePopup) {
    hideWorkspacePopup();
  }
};

rectanglePopup.onclick = (e) => {
  if (e.target === rectanglePopup) {
    hideRectanglePopup();
  }
};

// --- Zoom controls ---

zoomInBtn.onclick = () => {
  if (currentZoomIndex < ZOOM_LEVELS.length - 1) {
    currentZoomIndex++;
    setZoom(ZOOM_LEVELS[currentZoomIndex]);
  }
};

zoomOutBtn.onclick = () => {
  if (currentZoomIndex > 0) {
    currentZoomIndex--;
    setZoom(ZOOM_LEVELS[currentZoomIndex]);
  }
};

// --- Events ---

canvas.addEventListener("mousedown", onMouseDown);
canvas.addEventListener("mousemove", onMouseMove);
canvas.addEventListener("mouseup", onMouseUp);
canvas.addEventListener("mouseleave", onMouseUp);
canvas.addEventListener("dblclick", onDoubleClick);

// Touch support for mobile
canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  const mouseEvent = new MouseEvent("mousedown", {
    clientX: touch.clientX,
    clientY: touch.clientY
  });
  canvas.dispatchEvent(mouseEvent);
});

canvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  const mouseEvent = new MouseEvent("mousemove", {
    clientX: touch.clientX,
    clientY: touch.clientY,
    buttons: 1
  });
  canvas.dispatchEvent(mouseEvent);
});

canvas.addEventListener("touchend", (e) => {
  e.preventDefault();
  const mouseEvent = new MouseEvent("mouseup", {});
  canvas.dispatchEvent(mouseEvent);
});

// Mouse wheel zoom
canvas.addEventListener("wheel", (e) => {
  e.preventDefault();
  const delta = e.deltaY > 0 ? -1 : 1;

  if (delta > 0 && currentZoomIndex < ZOOM_LEVELS.length - 1) {
    currentZoomIndex++;
    setZoom(ZOOM_LEVELS[currentZoomIndex]);
  } else if (delta < 0 && currentZoomIndex > 0) {
    currentZoomIndex--;
    setZoom(ZOOM_LEVELS[currentZoomIndex]);
  }
});

// Keyboard shortcuts
document.addEventListener("keydown", (e) => {
  // Close popups with Escape key
  if (e.key === 'Escape') {
    if (workspacePopup.classList.contains('show')) {
      hideWorkspacePopup();
      return;
    }
    if (rectanglePopup.classList.contains('show')) {
      hideRectanglePopup();
      return;
    }
  }

  // Skip other shortcuts if any popup is open
  if (workspacePopup.classList.contains('show') || rectanglePopup.classList.contains('show')) {
    return;
  }

  if (e.key === "Delete" || e.key === "Backspace") {
    if (selected) {
      deleteBtn.click();
    }
  } else if (e.key === "n" || e.key === "N") {
    addBtn.click();
  } else if (e.key === "+" || e.key === "=") {
    zoomInBtn.click();
  } else if (e.key === "-" || e.key === "_") {
    zoomOutBtn.click();
  }
});

// Initialize the application
function initializeApp() {
  // Center the workspace in the canvas view
  const workspaceWidth = WORKSPACE_WIDTH_MM * BASE_SCALE * zoom;
  const workspaceHeight = WORKSPACE_HEIGHT_MM * BASE_SCALE * zoom;

  panX = (canvas.width - workspaceWidth) / 2;
  panY = (canvas.height - workspaceHeight) / 2;

  updateZoomDisplay();
  draw();
  updateInfo();
}

// Initial draw with welcome animation
setTimeout(() => {
  initializeApp();
}, 100);

// Add a welcome box
setTimeout(() => {
  const workspaceWidth = WORKSPACE_WIDTH_MM * BASE_SCALE;
  const workspaceHeight = WORKSPACE_HEIGHT_MM * BASE_SCALE;

  const welcomeRect = {
    x: workspaceWidth / 2 - 30, // 200mm from left (centered)
    y: workspaceHeight / 2 - 20, // 150mm from top (centered)
    w: 60, // 60mm wide
    h: 40, // 40mm tall
    color: "#6b7280",
    opacity: 0.7,  // Individual box opacity (70% default)
    zIndex: 0  // Layer ordering
  };
  boxes.push(welcomeRect);
  selectRectangle(welcomeRect);
  animateRectangleCreation(welcomeRect);
}, 500);
</script>

</body>
</html>